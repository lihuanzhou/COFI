# -*- coding: utf-8 -*-
"""5 - match - from round 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19cvX1mmN2Z-AaZe6ewVVAuS-0BrcFVSh
"""

import pandas as pd
import string
import numpy as np


"""Strategy for matching and finding the same power plants:
* equal join on: "Recipient ISO-3", "primary_fuel" (if it is there)
* fuzzy join:
    * "installed_capacity"
    * "additional_info"
    * city and province
"""

cofi_pp_columns = ['country_iso3c', "primary_fuel", "installed_capacity", "power_plant_name", "city", "province"]
aiddata_pp_columns = ["Recipient ISO-3", "primary_fuel", "installed_capacity", "additional_info", "city", "province"]

"""Strategy for matching and finding the same investment info:
* match first for the power plant
* fuzzy join:
    * "Commitment Year"
    * "Funding Agencies" and "Co-financing Agencies"
    * "Amount (Constant USD 2021)"
    * "installed_capacity"
    * "additional_info"

"""

def preprocess_text(text, remove_punctuation = False):
  # Implement your preprocessing logic here (e.g., lowercase conversion)

    new_string = text.lower()

    if remove_punctuation is True:
        # Create a translation table
        translator = str.maketrans('', '', string.punctuation)
        # Remove punctuation
        new_string = new_string.translate(translator)

    return new_string

"""## 1. Load data"""

aid = pd.read_excel("AidData - All Plants with extracted info - round 3.xlsx")
aid = aid.drop(columns=["GPT answer - capacity and fuel", "GPT answer - city and province", 'encoding Description', 'Present', 'GPT answer',
      'CPG answer - capacity and fuel', 'capcity', "Amount (Constant USD 2021)"	,"Adjusted Amount (Constant USD 2021)"])
aid.head()

aid.tail()

aid.shape

aid = aid.sort_values(by="AidData Record ID")
aid = aid.reset_index()
aid = aid.drop(columns =["index"])

cofi = pd.read_excel("../Round 1/cofi_v2.2_final.xlsx")

columns_to_keep_cofi = ["unique_id",
                        'power_plant_name', "installed_capacity", 'primary_fuel', # matching "Title" in AidData
                        "city", "province", # will match the "city" and "province" newly extracted
                        'country_iso3c', # "Recipient ISO-3"
                        'debt_investment_year', # "Commitment Year"
                        'debt_investment_amount', # matching amount fields
                        # matching the "Funding Agencies" and "Co-financing Agencies" and the amount fields and the investment type, just for Debt
                        'bank_of_china', 'china_development_bank',
                        'export_import_bank_of_china',
                        'industrial_and_commercial_bank_of_china', 'china_construction_bank',
                        'bank_of_communications', 'agricultural_bank_of_china',
                        'china_citic_bank_corp', 'china_merchants_bank',
                        'china_minsheng_banking_corp', 'china_zheshang_bank',
                        'china_everbright_bank', 'silk_road_fund',
                        'china_co-financing_fund_for_latin_america_and_the_caribbean']

cofi = cofi[columns_to_keep_cofi].copy(deep=True)
cofi.head()

cofi.shape

"""## 2. Prepare datasets for matching

So, let's have this convention:
* for the text columns: if there is no data put ""
* for the numerical data: if there is no data put np.nan
"""

cofi[cofi_pp_columns].isna().sum()

cofi['power_plant_name'] = cofi['power_plant_name'].fillna("")
cofi['city'] = cofi['city'].fillna("")
cofi['province'] = cofi['province'].fillna("")

cofi[cofi_pp_columns].dtypes

aid[aiddata_pp_columns].isna().sum()

aid["Recipient ISO-3"] = aid["Recipient ISO-3"].fillna("")
aid["primary_fuel"] = aid["primary_fuel"].fillna("")
aid["additional_info"] = aid["additional_info"].fillna("")
aid['city'] = aid['city'].fillna("")
aid['province'] = aid['province'].fillna("")

aid[aiddata_pp_columns].dtypes

aid['Amount (Nominal USD)'].dtypes

aid['Funding Agencies'] = aid['Funding Agencies'].fillna("")

"""## 3. Do matching with power plant"""

def do_match(row, threshold_installed_capacity = 300, use_multiplier = False, multipliers = [2, 3, 4, 5]):
    # equal join
    potential = cofi.loc[cofi['country_iso3c'] == row['Recipient ISO-3']]
    potential = potential.loc[potential['primary_fuel'] == row["primary_fuel"]]

    if np.isnan(row['installed_capacity']):
        # then we can't do a match
        potential = potential.drop(potential.index)

    # fuzzy join
    if use_multiplier is False and not(np.isnan(row['installed_capacity'])):
        # use just the range method
        potential = potential.loc[(potential['installed_capacity'] <= row['installed_capacity'] + threshold_installed_capacity) & (potential['installed_capacity'] >= row['installed_capacity'] - threshold_installed_capacity)]
    elif use_multiplier is True and not(np.isnan(row['installed_capacity'])):

        # also try the multiplier relations
        potentials = []
        for multiplier in multipliers:
            potentials.append(potential.loc[potential['installed_capacity'] == row['installed_capacity'] * multiplier])
        # get the ones with the range
        potentials.append(potential.loc[(potential['installed_capacity'] <= row['installed_capacity'] + threshold_installed_capacity) & (potential['installed_capacity'] >= row['installed_capacity'] - threshold_installed_capacity)])

        potential = pd.concat(potentials)
        potential = potential.drop_duplicates()

    return potential

"""#### Check different thresholds"""

from statistics import mean, stdev

thresholds = [300, 200, 100, 0]

# NO MULTIPLIER
thr_rows = []
for thr in thresholds:
    counter = 0
    values = []
    for i, row in aid.iterrows():
        potential = do_match(row, thr, False)
        values.append(potential.shape[0])
        if potential.shape[0] and np.isnan(row['installed_capacity']):
            counter += 1

    matches = sum([x > 0 for x in values])
    no_matches = sum([x == 0 for x in values])

    row = [thr, matches, no_matches, mean(values), stdev(values), max(values), min(values)]
    thr_rows.append(row)
    print(counter)

pd.DataFrame(thr_rows, columns=["Threshold", "# Matches", "# No Matches", "Mean", "Std", "Max", "Min"])

# YES MULTIPLER
thr_rows = []
for thr in thresholds:
    values = []
    counter = 0
    for i, row in aid.iterrows():
        potential = do_match(row, thr, True)
        values.append(potential.shape[0])
        if potential.shape[0] and np.isnan(row['installed_capacity']):
            counter += 1

    matches = sum([x > 0 for x in values])
    no_matches = sum([x == 0 for x in values])

    row = [thr, matches, no_matches, mean(values), stdev(values), max(values), min(values)]
    thr_rows.append(row)
    print(counter)

pd.DataFrame(thr_rows, columns=["Threshold", "# Matches", "# No Matches", "Mean", "Std", "Max", "Min"])

# YES MULTIPLER
values = []
for i, row in aid.iterrows():
    potential = do_match(row, 0, True)
    if potential.shape[0] > 0:
        if len([x for x in potential['installed_capacity'].to_list() if x != row['installed_capacity']]) > 0:
            values.append(row['primary_fuel'])

set(values)

"""#### Check the similarity between additional_info and power_plant_name, between city columns, between province columns"""

from thefuzz import fuzz

aid['additional_info'] = aid['additional_info'].apply(preprocess_text)
aid['city'] = aid['city'].apply(preprocess_text)
aid['province'] = aid['province'].apply(preprocess_text)
cofi['power_plant_name'] = cofi['power_plant_name'].apply(preprocess_text)
cofi['city'] = cofi['city'].apply(preprocess_text)
cofi['province'] = cofi['province'].apply(preprocess_text)

aid[['city', "province"]].head(2)

def compute_similarity(text_1, text_2):
    if text_1 == "" and text_2 == "":
        return 0
    else:
        return fuzz.partial_ratio(text_1, text_2)

thr = 0
rows = []
for i, row in aid.iterrows():
    potential = do_match(row, thr, False)
        # since there are multiple results, we compute the matching for all the results
        # and then get the best score for the three columns we are comparning (name, city and province)
    if potential.shape[0] == 0:
        continue
    potential = potential.reset_index()
    name_sims = []
    city_sims = []
    province_sims = []
    for _, row_potential in potential.iterrows():
        name_sims.append(compute_similarity(row['additional_info'], row_potential['power_plant_name']))
        # name_sims.append(compute_similarity(row['name'], row_potential['power_plant_name']))
        city_sims.append(compute_similarity(row['city'], row_potential['city']))
        province_sims.append(compute_similarity(row['province'], row_potential['province']))

    sim_name = max(name_sims)
    sim_city = max(city_sims)
    sim_province = max(province_sims)

    sims = [sim_name, sim_city, sim_province]

    new_row = [i, sim_name, sim_city, sim_province, max(sims), min(sims)]
    rows.append(new_row)

matching_on_additional_info = pd.DataFrame(rows, columns=["AidData row", "Name", "City", "Province", "Max", "Min"])
matching_on_additional_info

for col in ['Name', 'City', 'Province']:
    values = matching_on_additional_info[col].to_list()
    count = 103
    print(col)
    print(f"mean: {mean(values)}")
    print(f"std: {stdev(values)}")
    for sim_thr in [70, 80, 90, 95]:
        print(f"% > {sim_thr}: {sum([x > sim_thr for x in values]) / count * 100:.2f}")

    print("")

"""#### Compute how many rows in AidData have multiple matches in COFI"""

# compute for how many rows there are multiple matches: for these rows we do neet to know how to pick one best match
thr = 0
sizes = []
for i, row in aid.iterrows():
    potential = do_match(row, thr, False)
    sizes.append(potential.shape[0])

len([x for x in sizes if x > 1])

"""#### Use different functions to compute similarities"""

def compute_similarity_v2(text_1, text_2, func = fuzz.partial_token_set_ratio):
    if text_1 == "" and text_2 == "":
        return 0
    else:
        return func(text_1, text_2)

thr = 0
datasets = {}
for func in [fuzz.partial_ratio, fuzz.partial_token_set_ratio, fuzz.partial_token_sort_ratio, fuzz.ratio]:
    rows = []
    for i, row in aid.iterrows():
        potential = do_match(row, thr, False)
            # since there are multiple results, we compute the matching for all the results
            # and then get the best score for the three columns we are comparning (name, city and province)
        if potential.shape[0] == 0:
            continue
        potential = potential.reset_index()
        name_sims = []
        city_sims = []
        province_sims = []
        for _, row_potential in potential.iterrows():
            name_sims.append(compute_similarity_v2(row['additional_info'], row_potential['power_plant_name'], func))
            # name_sims.append(compute_similarity_v2(row['name'], row_potential['power_plant_name'], func))
            city_sims.append(compute_similarity_v2(row['city'], row_potential['city'], func))
            province_sims.append(compute_similarity_v2(row['province'], row_potential['province'], func))

        sim_name = max(name_sims)
        sim_city = max(city_sims)
        sim_province = max(province_sims)

        sims = [sim_name, sim_city, sim_province]

        new_row = [i, sim_name, sim_city, sim_province, max(sims), min(sims)]
        rows.append(new_row)

    # save the information for this function
    datasets[func] = pd.DataFrame(rows, columns=["AidData row", "Name", "City", "Province", "Max", "Min"])

datasets[fuzz.partial_ratio]

rows = []
count = 103
for func in [fuzz.partial_ratio, fuzz.partial_token_set_ratio, fuzz.partial_token_sort_ratio, fuzz.ratio]:
    row = [str(func).split(" ")[1]]
    db = datasets[func]

    for col in ["Name", "City", "Province"]:
        values = db[col].to_list()
        row.append(mean(values))
        row.append(stdev(values))

    rows.append(row)

sim_res = pd.DataFrame(rows, columns=['Function', "Name: mean", "Name: std", "City: mean", "City: std", "Province: mean", "Province: std"])
sim_res

for col in ['Name: mean', "City: mean", "Province: mean"]:
    id = sim_res[col].idxmax()
    print(f"{col}: {sim_res.iloc[id]["Function"]}")

"""#### Manually check the matching"""

aid = aid.rename(columns={"additional_info": "name"})

thr = 0
to_print = []
#for i in samples:
for i in matching_on_additional_info['AidData row'].to_list():
    row = aid.iloc[i]
    potential = do_match(row, thr, False)
    potential = potential.reset_index()
    potential = potential.drop(columns="index")
    for i_potential, row_potential in potential.iterrows():
            potential.at[i_potential, "Sim Name"] = compute_similarity_v2(row['name'], row_potential['power_plant_name'])
            potential.at[i_potential, "Sim City"] = compute_similarity_v2(row['city'], row_potential['city'])
            potential.at[i_potential, "Sim Province"] = compute_similarity_v2(row['province'], row_potential['province'])

    potential = potential.sort_values(by=['Sim Name', "Sim Province", "Sim City"], ascending=False)

    to_print.append([row, potential, row['AidData Record ID']])

columns_cofi_to_print = list(cofi.columns[0:4]) + ["province", "city", "country_iso3c"] + ['Sim Name', "Sim Province", "Sim City"] + list(cofi.columns[7:])

aid_columns_to_print = ['AidData Record ID', 'name', 'installed_capacity', "primary_fuel", "province", "city", 'Recipient ISO-3', "Title"] + list(aid.columns[3: 5]) + list(aid.columns[6: 8]) + ['Description']

len(to_print)

# Create an ExcelWriter object
writer = pd.ExcelWriter('All matches - Power Plant v3.xlsx', engine='xlsxwriter')

for i in range(len(to_print)):
    # Write the first DataFrame to a specific sheet name and starting row
    df1 = pd.DataFrame(to_print[i][0]).transpose()[aid_columns_to_print]
    df1.to_excel(writer, sheet_name='AidData ID ' + str(to_print[i][2]), startrow=0, index=False)

    # Write the second DataFrame to the same sheet but starting from a new row below the first DataFrame
    startrow_for_df2 = len(df1) + 2  # Add 2 for spacing between DataFrames
    df2 = to_print[i][1][columns_cofi_to_print]
    df2.to_excel(writer, sheet_name='AidData ID ' + str(to_print[i][2]), startrow=startrow_for_df2, index=False)

# Save the Excel file
writer.close()

# check
temp = pd.read_excel('All matches - Power Plant v3.xlsx', sheet_name=None)
len(temp)

"""#### Get the unique IDs in COFI not matched in AidData"""

to_print[1][1]['unique_id'].to_list()

unique_ids_pp = []
for i in range(len(to_print)):
    unique_ids_pp.extend(to_print[i][1]['unique_id'].to_list())

len(set(unique_ids_pp))

matched_pp_list = list(list(set(unique_ids_pp)))
matched_pp_list.sort()
len(matched_pp_list)

not_matched_pp = []
for cofi_id in cofi['unique_id'].unique():
    if cofi_id not in set(unique_ids_pp):
        not_matched_pp.append(cofi_id)

not_matched_pp_list = list(set(not_matched_pp))
not_matched_pp_list.sort()

pd.DataFrame(not_matched_pp_list, columns=['Not matched PP']).to_excel("COFI - not matched in AidData Power Plant.xlsx")

pd.DataFrame(matched_pp_list, columns=['Matched PP']).to_excel("COFI - matched in AidData Power Plant.xlsx")

print(set(not_matched_pp_list) & set(matched_pp_list) == set())
print(len(not_matched_pp_list) + len(matched_pp_list) == len(cofi))

"""## 4. Do matching of the investments

Of the ones that I found matching with the power plant, I need to see if they match the data for the investment:
* so, they usually discuss loans in the Funding Agencies, so we should match with the columns
* we could check if the investors in the cofi dataset is in the description of the row.

So, from what I see:
* there are matches on the matches on the power plant (since we have a 100+ matches using thr=0)
* there is shared info but something differes (e.g. the amounts and the year)

Strategy for matching and finding the same investment info:
* match first for the power plant
* fuzzy join:
    * "Commitment Year"
    * "Funding Agencies" and "Co-financing Agencies"
"""

aid['Funding Agencies'] = aid['Funding Agencies'].apply(lambda x: x.lower())

temp = aid.iloc[matching_on_additional_info['AidData row'].to_list()]
temp.loc[temp['Funding Agencies'].str.contains("\|")].shape[0]

aid.loc[aid['AidData Record ID'] == 96123]['Funding Agencies'].values[0]

"""#### Do the match

We can use a dictionary to convert the names of the banks in the Aid data to the banks in the cofi database(these are in the names of the columns).
"""

company_dict_df = pd.read_excel("../Round 1/Funding Acengies dictionary.xlsx")
company_dict = {}
for i, row in company_dict_df.iterrows():
    company_dict[row['Old']] = row['New']
company_dict

# Only apply the computing the investments on the rows that were matched at the power plant level (no multiplier)
index_to_study = matching_on_additional_info['AidData row'].to_list()

len(index_to_study)

rows = []
counter = 0
threshold_year = 1
for index in index_to_study:
    row = aid.iloc[index]
    potential = do_match(row, 0, False)

    # fuzzy join on year
    potential = potential.loc[(potential['debt_investment_year'] <= row['Commitment Year'] + threshold_year) & (potential['debt_investment_year'] >= row['Commitment Year'] - threshold_year)]

    # compute similarity scores on the equity names
    # check similarity between the "Funding Agencies" and "equity_investor_name"
    potential = potential.reset_index()
    potential = potential.drop(columns=['index'])

    banks_present_in_cofi = 0
    counter_2 = 0
    for agency in row['Funding Agencies'].split("|"):
        if agency in company_dict:
            banks_present_in_cofi += 1
    values = [0]
    for i_p, row_p in potential.iterrows():
        values_present_in_cofi = 0
        for agency in row['Funding Agencies'].split("|"):
            if agency in company_dict:
                if not (np.isnan(row_p[company_dict[agency]])):
                    values_present_in_cofi += 1
        values.append(values_present_in_cofi)

    agencies_no = len(row['Funding Agencies'].split("|"))
    matches_bank_no = max(values)


    rows.append([index, potential.shape[0], banks_present_in_cofi, matches_bank_no, matches_bank_no / agencies_no * 100])

banks_matches = pd.DataFrame(rows, columns=['AidData row', "Year", "# bank matches", "# of values in row", "% over agencies"])
banks_matches

banks_matches.loc[banks_matches['Year'] > 0].shape[0]

banks_matches['# bank matches'].value_counts()

banks_matches.shape[0] - banks_matches.loc[banks_matches['# bank matches'] > 0].shape[0]

banks_matches.loc[banks_matches["# of values in row"] > 0].shape[0]

banks_matches["% over agencies"].value_counts()

banks_matches.loc[banks_matches["% over agencies"] == 100].shape[0]

"""#### Create results to be manually checked (old)"""

# len(matching_on_additional_info['AidData row'].to_list())

# thr = 0
# threshold_year = 1
# to_print_2 = []
# #for i in samples:
# for i in matching_on_additional_info['AidData row'].to_list():
#     row = aid.iloc[i]
#     potential = do_match(row, thr, True)
#     potential = potential.reset_index()
#     potential = potential.drop(columns="index")
#     for i_potential, row_potential in potential.iterrows():
#             #potential.at[i_potential, "Sim Name"] = fuzz.partial_ratio(row['additional_info'], row_potential['power_plant_name'])
#             potential.at[i_potential, "Sim Name"] = fuzz.partial_ratio(row['name'], row_potential['power_plant_name'])
#             potential.at[i_potential, "Sim City"] = fuzz.partial_ratio(row['city'], row_potential['city'])
#             potential.at[i_potential, "Sim Province"] = fuzz.partial_ratio(row['province'], row_potential['province'])

#     # fuzzy join on year
#     potential = potential.loc[(potential['debt_investment_year'] <= row['Commitment Year'] + threshold_year) & (potential['debt_investment_year'] >= row['Commitment Year'] - threshold_year)]

#     # compute the similarity score on the "equity_investor_1"
#     potential = potential.reset_index()
#     potential = potential.drop(columns=['index'])

#     for i_p, row_p in potential.iterrows():
#         values_present_in_cofi = 0
#         for agency in row['Funding Agencies'].split("|"):
#             if agency in company_dict:
#                 if not (np.isnan(row_p[company_dict[agency]])):
#                     values_present_in_cofi += 1
#         potential.at[i_p, "Shared banks #"] = values_present_in_cofi
#         potential.at[i_p, "Shared banks %"] = values_present_in_cofi / len(row['Funding Agencies'].split("|")) * 100
#     if potential.shape[0] == 0:
#         # needed to make sure that the printing mechanism is smooth
#         potential.at[i_p, "Shared banks #"] = ""
#         potential.at[i_p, "Shared banks %"] = ""
#         # the previous two rows added a row in the potential df which is supposed to be empty to begin with
#         potential = potential.drop(potential.index)

#     potential = potential.sort_values(by=['Sim Name', "Sim Province", "Shared banks %"], ascending=False)

#     to_print_2.append([row, potential, i])

# sum([x > 0 for x in [x.shape[0] for row, x, i in to_print_2]])

# len(to_print_2)

# columns_cofi_to_print[0:9] + ["Shared banks #", "Shared banks %"] + columns_cofi_to_print[9:]

# # Create an ExcelWriter object
# writer = pd.ExcelWriter('All matches - Investments v3.xlsx', engine='xlsxwriter')

# for i in range(len(to_print_2)):
#     # Write the first DataFrame to a specific sheet name and starting row
#     df1 = pd.DataFrame(to_print_2[i][0]).transpose()[aid_columns_to_print]
#     df1.to_excel(writer, sheet_name='AidData row ' + str(to_print_2[i][2]), startrow=0, index=False)

#     # Write the second DataFrame to the same sheet but starting from a new row below the first DataFrame
#     startrow_for_df2 = len(df1) + 2  # Add 2 for spacing between DataFrames
#     #df2 = to_print[i][1][printing_cols]
#     df2 = to_print_2[i][1][columns_cofi_to_print[0:9] + ["Shared banks #", "Shared banks %"] + columns_cofi_to_print[9:]]
#     df2.to_excel(writer, sheet_name='AidData row ' + str(to_print_2[i][2]), startrow=startrow_for_df2, index=False)

# # Save the Excel file
# writer.close()

# to_print_2[-1][1]

# lines = 0
# counter = 0
# multiplier_worked = 0
# ids_multiplier = []
# for i in range(len(to_print_2)):
#     if to_print_2[i][1].shape[0] > 1:
#         # print(to_print[i][1].head(1)['Sim Name'].values[0])
#         # if to_print[i][1].head(1)['Sim Name'].values[0] != 100:
#         #     print(to_print[i][1].head(1)['Sim Province'].values[0])
#         lines += 1
#         if to_print_2[i][1].head(1)['Shared banks %'].values[0] == 100:
#             counter += 1

# counter/lines*100

# counter

# lines

# aid["Amount (Nominal USD)"]

"""#### Check the difference in the amounts

Assumptions:
* the amount refers to the main funding agency in "Funding Agencies"

So, let's disregard for a moment these entries where the are multiple funding agencies.
"""

indexes = []
for i in matching_on_additional_info['AidData row'].to_list():
    row = aid.iloc[i]
    if "|" in row['Funding Agencies']:
        print(f"{i}: {row['Title']}")
        print(f"{row['Funding Agencies']}\n")
        indexes.append(i)

indexes

"""
This is important for when computing the difference:
* COFI values: are in million of dollars (so 1 million is "1")
* AidData: values are directly in normal values (so 1 million is "1000000")</br>"""

banks_matches

"""##### Compute the differences amount for all those entries that present only one bank in "Funding Agencies"."""

thr = 0
threshold_year = 1
to_print_2 = []
amount_column_aid = "Amount (Nominal USD)"
rows = []
#for i in samples:
for i in list(banks_matches.loc[banks_matches['# of values in row'] > 0]['AidData row']):
    row = aid.iloc[i]

    if "|" in row['Funding Agencies']:
        continue

    potential = do_match(row, thr, False)
    potential = potential.reset_index()
    potential = potential.drop(columns="index")
    for i_potential, row_potential in potential.iterrows():
            #potential.at[i_potential, "Sim Name"] = fuzz.partial_ratio(row['additional_info'], row_potential['power_plant_name'])
            potential.at[i_potential, "Sim Name"] = compute_similarity_v2(row['name'], row_potential['power_plant_name'])
            potential.at[i_potential, "Sim City"] = compute_similarity_v2(row['city'], row_potential['city'])
            potential.at[i_potential, "Sim Province"] = compute_similarity_v2(row['province'], row_potential['province'])

    # fuzzy join on year
    potential = potential.loc[(potential['debt_investment_year'] <= row['Commitment Year'] + threshold_year) & (potential['debt_investment_year'] >= row['Commitment Year'] - threshold_year)]

    # compute the similarity score on the "equity_investor_1"
    potential = potential.reset_index()
    potential = potential.drop(columns=['index'])


    if "|" not in row['Funding Agencies']:
        for i_p, row_p in potential.iterrows():
            # values_present_in_cofi = 0
            # for agency in row['Funding Agencies'].split("|"):
            #     if agency in company_dict:
            #         if not (np.isnan(row_p[company_dict[agency]])):
            #             values_present_in_cofi += 1
            # potential.at[i_p, "Shared banks #"] = values_present_in_cofi
            # potential.at[i_p, "Shared banks %"] = values_present_in_cofi / len(row['Funding Agencies'].split("|")) * 100

            # since there is only one agency per row, we can save the information directly in one value
            potential.at[i_p, "difference"] = -1 # default value in case there are is no value in potential to compare it to
            if row['Funding Agencies'].strip() in company_dict:
                if not (np.isnan(row_p[company_dict[row['Funding Agencies'].strip()]])):
                    potential.at[i_p, "difference"] = abs(row[amount_column_aid] - row_p[company_dict[row['Funding Agencies'].strip()]] * 1000000)

    if potential.shape[0] > 0:
        potential = potential.sort_values(by=['Sim Name', "Sim Province", "Sim City", "difference"], ascending=False)
        to_compare = [x for x in list(potential['difference']) if x != -1 and not(np.isnan(x))]
        if len(to_compare) > 0:
            min_diff = min(to_compare)
        else:
            min_diff = -1

    if potential.shape[0] == 0:
        min_diff = -1

    to_print_2.append([row, potential, row['AidData Record ID'], min_diff])
    rows.append([i, min_diff])

diff_df = pd.DataFrame(rows, columns=["AidData row", "Least difference"])
diff_df

missing = diff_df.loc[diff_df['Least difference'] == -1].shape[0]
print(f"No match with COFI #: {missing}")
print(f"No match with COFI %: {missing / diff_df.shape[0] * 100}")
print(f"Indexes: {diff_df.loc[diff_df['Least difference'] == -1]['AidData row'].to_list()}")
# this row 273: there is no nominal amount

aid.iloc[273]

values = list(diff_df.loc[diff_df['Least difference'] != -1]['Least difference'])
print(f"mean: {mean(values)}")
print(f"std: {stdev(values)}")

"""##### Compute the differences amount for all those entries that present MULTIPLE banks in "Funding Agencies".

Here we compute the difference for those entries that have multiple banks in "Funding Agencies"
* for these we equally distribute the investment value in the row in AidData among the investors in "Funding Agencies";
* we then compute the difference for each investor with their correspoding values in the COFI entries;
* we then take the lowest of these differences and we use it to represent the least difference for the AidData column (these values are used above when computing the distribution of the differences).
"""

cofi["differences per bank"] = ""

thr = 0
threshold_year = 1
to_print_2_special = []
amount_column_aid = "Amount (Nominal USD)"
averages = []
rows = []
#for i in samples:
for i in indexes:
    row = aid.iloc[i]

    potential = do_match(row, thr, True)
    potential = potential.reset_index()
    potential = potential.drop(columns="index")
    for i_potential, row_potential in potential.iterrows():
            #potential.at[i_potential, "Sim Name"] = fuzz.partial_ratio(row['additional_info'], row_potential['power_plant_name'])
            potential.at[i_potential, "Sim Name"] = compute_similarity_v2(row['name'], row_potential['power_plant_name'])
            potential.at[i_potential, "Sim City"] = compute_similarity_v2(row['city'], row_potential['city'])
            potential.at[i_potential, "Sim Province"] = compute_similarity_v2(['province'], row_potential['province'])

    # fuzzy join on year
    potential = potential.loc[(potential['debt_investment_year'] <= row['Commitment Year'] + threshold_year) & (potential['debt_investment_year'] >= row['Commitment Year'] - threshold_year)]

    # compute the similarity score on the "equity_investor_1"
    potential = potential.reset_index()
    potential = potential.drop(columns=['index'])


    print(potential.shape[0])
    tmp = []
    for i_p, row_p in potential.iterrows():
            # values_present_in_cofi = 0
            # for agency in row['Funding Agencies'].split("|"):
            #     if agency in company_dict:
            #         if not (np.isnan(row_p[company_dict[agency]])):
            #             values_present_in_cofi += 1
            # potential.at[i_p, "Shared banks #"] = values_present_in_cofi
            # potential.at[i_p, "Shared banks %"] = values_present_in_cofi / len(row['Funding Agencies'].split("|")) * 100

            # since there is only one agency per row, we can save the information directly in one value
            potential.at[i_p, "difference"] = "None" # default value in case there are is no value in potential to compare it to
            diff_dict = {}
            investors_no = len(row['Funding Agencies'].split("|"))
            for agency in row['Funding Agencies'].split("|"):
                if agency.strip() in company_dict:
                        if not (np.isnan(row_p[company_dict[agency.strip()]])):
                               diff_dict[company_dict[agency.strip()]] = abs(row[amount_column_aid] / investors_no - row_p[company_dict[agency.strip()]] * 1000000)
                        else:
                               diff_dict[company_dict[agency.strip()]] = -1
            potential.at[i_p, "differences per bank"] = diff_dict
            if len(diff_dict) > 0:
                        vals  = [x for x in list(diff_dict.values()) if x != -1 and not(np.isnan(x))]
                        if len(vals) > 0:
                                tmp.append(mean(vals))
                                potential.at[i_p, "difference"] = mean(vals)



    min_diff = -1
    if len(tmp) > 0:
            min_diff = min(tmp)
            averages.append(min_diff)
    if potential.shape[0] > 0:
        potential = potential.sort_values(by=['Sim Name', "Sim Province", "Sim City", "difference"], ascending=[False, False, False, True])
        to_print_2_special.append([row, potential, row['AidData Record ID'], min_diff])

len(to_print_2_special) + len(to_print_2)

averages

# # save these values
# to_print_2 = to_print_2_special
# # Create an ExcelWriter object
# writer = pd.ExcelWriter('All matches - Investments v3 - special values.xlsx', engine='xlsxwriter')

# for i in range(len(to_print_2)):
#     # Write the first DataFrame to a specific sheet name and starting row
#     df1 = pd.DataFrame(to_print_2[i][0]).transpose()[aid_columns_to_print[0:10] + ["Amount (Nominal USD)"] + aid_columns_to_print[10:] ]
#     df1.to_excel(writer, sheet_name='AidData row ' + str(to_print_2[i][2]), startrow=0, index=False)

#     # Write the second DataFrame to the same sheet but starting from a new row below the first DataFrame
#     startrow_for_df2 = len(df1) + 2  # Add 2 for spacing between DataFrames
#     #df2 = to_print[i][1][printing_cols]
#     if to_print_2[i][1].shape[0] == 0:
#         continue
#     df2 = to_print_2[i][1][columns_cofi_to_print[0:9] + ["difference", "differences per bank"] + columns_cofi_to_print[9:]]
#     df2.to_excel(writer, sheet_name='AidData row ' + str(to_print_2[i][2]), startrow=startrow_for_df2, index=False)

#     startrow_for_df3 = len(df1) + 2 + len(df2) + 2
#     df3 = pd.DataFrame([to_print_2[i][3]], columns=['Difference'])
#     df3.to_excel(writer, sheet_name='AidData row ' + str(to_print_2[i][2]), startrow=startrow_for_df3, index=False)

# # Save the Excel file
# writer.close()

"""##### Check the distribution of the values

Note: "averages" is the difference values for the entries that have multiple banks in "Funding Agencies", it is computed below.
"""

new_diff_df = pd.concat([diff_df, pd.DataFrame([[-1, x] for x in averages], columns=['AidData row', "Least difference"])])

len(new_diff_df)

"""Now, look at the distribution of the differences values."""

import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt


# Create a KDE plot
colors = ["purple", "blue", "red", "green", "black", "orange", "magenta"]

#sns.kdeplot(values, color=colors[0])
plt.hist(new_diff_df['Least difference'])

plt.xlim([0, max(values)])

# Customize the plot (optional)
plt.legend()
plt.xlabel('Difference')
plt.ylabel('Quantity')
plt.title('Difference distribution')
plt.show()

valid = new_diff_df.loc[(new_diff_df['Least difference'] != -1)]

valid.shape[0]

rows = []
for thr in [pow(10, i) for i in [1, 2, 3, 4, 5, 6, 7, 8, 9]]:
    below =  valid.loc[(valid['Least difference'] < thr) & (valid['Least difference'] != -1)].shape[0]
    print(f"below {thr} #: {below}")
    print(f"below {thr} % {below / valid.shape[0] * 100}\n")
    rows.append([f"< {thr}", below, below / valid.shape[0] * 100])

t = pd.DataFrame(rows).transpose()
t.columns = t.iloc[0]
t = t.drop(0)
t[''] = ['#', "%"]
t = t[[""] + list(t.columns[0:-1])]
t = t.rename(columns={"< 1000": "<1k", "< 10000": "<10k",	"< 100000":	"<100k", "< 1000000": "< 1M",	"< 10000000": "< 10M",	"< 100000000": "<100M", "< 1000000000": "< 1G"})
t

len(to_print_2)

# # save these values

# # Create an ExcelWriter object
# writer = pd.ExcelWriter('All matches - Investments v3 - with difference in amounts.xlsx', engine='xlsxwriter')

# for i in range(len(to_print_2)):
#     # Write the first DataFrame to a specific sheet name and starting row
#     df1 = pd.DataFrame(to_print_2[i][0]).transpose()[aid_columns_to_print[0:10] + ["Amount (Nominal USD)"] + aid_columns_to_print[10:] ]
#     df1.to_excel(writer, sheet_name='AidData row ' + str(to_print_2[i][2]), startrow=0, index=False)

#     # Write the second DataFrame to the same sheet but starting from a new row below the first DataFrame
#     startrow_for_df2 = len(df1) + 2  # Add 2 for spacing between DataFrames
#     #df2 = to_print[i][1][printing_cols]
#     if to_print_2[i][1].shape[0] == 0:
#         continue
#     df2 = to_print_2[i][1][columns_cofi_to_print[0:9] + ["difference"] + columns_cofi_to_print[9:]]
#     df2.to_excel(writer, sheet_name='AidData row ' + str(to_print_2[i][2]), startrow=startrow_for_df2, index=False)

#     startrow_for_df3 = len(df1) + 2 + len(df2) + 2
#     df3 = pd.DataFrame([to_print_2[i][3]], columns=['Difference'])
#     df3.to_excel(writer, sheet_name='AidData row ' + str(to_print_2[i][2]), startrow=startrow_for_df3, index=False)

# # Save the Excel file
# writer.close()

"""#### Check how many rows do have multiple matches in COFI"""

len([x for x in to_print_2 if x[1].shape[0] > 1]) + len([x for x in to_print_2_special if x[1].shape[0] > 1])

"""#### Get all the IDs in COFI that are not matched with any value in COFI"""

len(to_print_2) + len(to_print_2_special)

to_print_2_special[0][1]['unique_id'].to_list()

cofi_ids_investment = []
for i in range(len(to_print_2)):
    cofi_ids_investment.extend(to_print_2[i][1]['unique_id'].to_list())

for i in range(len(to_print_2_special)):
    cofi_ids_investment.extend(to_print_2_special[i][1]['unique_id'].to_list())

cofi_ids_investment_list = list(set(cofi_ids_investment))
cofi_ids_investment_list.sort()

pd.DataFrame(cofi_ids_investment_list, columns=['Matched in investment']).to_excel("COFI - matched in AidData investment.xlsx")

not_matched_investment = []
for cofi_id in set(cofi['unique_id'].to_list()):
    if cofi_id not in cofi_ids_investment_list:
        not_matched_investment.append(cofi_id)

not_matched_investment_list = list(set(not_matched_investment))
not_matched_investment_list.sort()

pd.DataFrame(not_matched_investment_list, columns=['Not matched in investment']).to_excel("COFI - not matched in AidData investment.xlsx")

print(set(not_matched_investment_list) & set(cofi_ids_investment_list) == set())
print(len(not_matched_investment_list) + len(cofi_ids_investment_list) == len(cofi))

len(matched_pp_list)

len(cofi_ids_investment_list)

"""#### Save all results

We print both the entries that have one bank in "Funding Agencies" and those that have multiples in one file.
"""

# Create an ExcelWriter object
writer = pd.ExcelWriter('All matches - Investments v3.xlsx', engine='xlsxwriter')

for i in range(len(to_print_2)):
    # Write the first DataFrame to a specific sheet name and starting row
    df1 = pd.DataFrame(to_print_2[i][0]).transpose()[aid_columns_to_print[0:11] + ["Amount (Nominal USD)"] + aid_columns_to_print[11:] ]
    df1.to_excel(writer, sheet_name='AidData ID ' + str(to_print_2[i][2]), startrow=0, index=False)

    # Write the second DataFrame to the same sheet but starting from a new row below the first DataFrame
    startrow_for_df2 = len(df1) + 2  # Add 2 for spacing between DataFrames
    #df2 = to_print[i][1][printing_cols]
    if to_print_2[i][1].shape[0] == 0:
        print("hello")
        continue
    df2 = to_print_2[i][1][columns_cofi_to_print[0:10] + ["difference"] + columns_cofi_to_print[10:]]
    df2.to_excel(writer, sheet_name='AidData ID ' + str(to_print_2[i][2]), startrow=startrow_for_df2, index=False)

    startrow_for_df3 = len(df1) + 2 + len(df2) + 2
    df3 = pd.DataFrame([to_print_2[i][3]], columns=['Least difference'])
    df3.to_excel(writer, sheet_name='AidData ID ' + str(to_print_2[i][2]), startrow=startrow_for_df3, index=False)

to_print_2 = to_print_2_special

for i in range(len(to_print_2)):
    # Write the first DataFrame to a specific sheet name and starting row
    df1 = pd.DataFrame(to_print_2[i][0]).transpose()[aid_columns_to_print[0:11] + ["Amount (Nominal USD)"] + aid_columns_to_print[11:]  ]
    df1.to_excel(writer, sheet_name='AidData ID ' + str(to_print_2[i][2]), startrow=0, index=False)

    # Write the second DataFrame to the same sheet but starting from a new row below the first DataFrame
    startrow_for_df2 = len(df1) + 2  # Add 2 for spacing between DataFrames
    #df2 = to_print[i][1][printing_cols]
    if to_print_2[i][1].shape[0] == 0:
        continue
    df2 = to_print_2[i][1][columns_cofi_to_print[0:10] + ["difference", "differences per bank"] + columns_cofi_to_print[10:]]
    df2.to_excel(writer, sheet_name='AidData ID ' + str(to_print_2[i][2]), startrow=startrow_for_df2, index=False)

    startrow_for_df3 = len(df1) + 2 + len(df2) + 2
    df3 = pd.DataFrame([to_print_2[i][3]], columns=['Least difference'])
    df3.to_excel(writer, sheet_name='AidData ID ' + str(to_print_2[i][2]), startrow=startrow_for_df3, index=False)

# Save the Excel file
writer.close()

# check
temp= pd.read_excel("All matches - Investments v3.xlsx", sheet_name=None)

len(temp)

"""Note: in COFI there are some results that have explicitly 0, so when we do the difference these are included (the difference is the value in Aid - 0 = the value in Aid): I thought this would distort the analysis of the differences but that doesn't happen, the distribution of the values (below "< 10", "< 100", etc.) isn't affected."""